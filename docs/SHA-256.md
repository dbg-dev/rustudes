# SHA-256

## Overview

SHA-256 (secure hash algorithm, FIPS 182-2) is a cryptographic hash function with a **digest** length of 256 bits. 
It is a keyless hash function, i.e., an MDC (Manipulation Detection Code).
A message is processed by blocks of $512=16 \times 32$ bits, each block requiring 64 rounds.
The algorithm is based on the [Merkle-Damgard construction](https://en.wikipedia.org/wiki/Merkle%E2%80%93Damg%C3%A5rd_construction).
This works on the premise that a collision-resistant cryptographic hash function can be constructed from a one-way compression function.

![Merkle-Damgard construction](./assets/Merkle-Damgard hash construction.png)

(Image from Wikipedia)

Breaking this down from the top:

- The message is broken into fixed-length blocks
- A [padding](#Padding) process to ensure the message is contained in blocks of identical length.

The bottom line of the diagram from left to right:

- IV is the [initialisation value](#Hash-initialisation).
- f is the [one-way compression function](#Hash-computation) called on each block
- [Finalisation](#Finalise) process

For this to work, we require a padding function with the following conditions, where $\left| M \right|$ denotes message length

- $M$ is a prefix of $\operatorname{Pad}(M)$.
- If $\left|M_1\right|=\left|M_2\right|$, then $\left|\operatorname{Pad}\left(M_1\right)\right|=\left|\operatorname{Pad}\left(M_2\right)\right|$.
- If $\left|M_1\right| \neq\left|M_2\right|$, then the last block of $\operatorname{Pad}\left(M_1\right)$ is different from the last block of $\operatorname{Pad}\left(M_2\right)$.

If the padding function meets these conditions then the collision resistance relies solely on the compression function.

## Basic operations

- Boolean operations AND, XOR and OR, denoted by $\wedge, \oplus$ and $\vee$, respectively.
- Bitwise complement, denoted by -.
- Integer addition modulo $2^{32}$, denoted by $A+B$.

Each of them operates on 32-bit words. For the last operation, binary words are interpreted as integers written in base 2.

- $\operatorname{Rot} R(A, n)$ denotes the circular right shift of $n$ bits of the binary word $A$.
- $\operatorname{ShR}(A, n)$ denotes the right shift of $n$ bits of the binary word $A$.
- $A \| B$ denotes the concatenation of the binary words $A$ and $B$.
## Functions

The algorithm uses the functions:
$$
\begin{aligned}
\operatorname{Ch}(X, Y, Z) & =(X \wedge Y) \oplus(\bar{X} \wedge Z), \\
\operatorname{Ma}(X, Y, Z) & =(X \wedge Y) \oplus(X \wedge Z) \oplus(Y \wedge Z), \\
\Sigma_{0}(X) & =\operatorname{RotR}(X, 2) \oplus \operatorname{RotR}(X, 13) \oplus \operatorname{RotR}(X, 22), \\
\Sigma_{1}(X) & =\operatorname{Rot} R(X, 6) \oplus \operatorname{Rot} R(X, 11) \oplus \operatorname{Rot} R(X, 25), \\
\sigma_{0}(X) & =\operatorname{RotR}(X, 7) \oplus \operatorname{Rot} R(X, 18) \oplus \operatorname{ShR}(X, 3), \\
\sigma_{1}(X) & =\operatorname{RotR}(X, 17) \oplus \operatorname{Rot} R(X, 19) \oplus \operatorname{ShR}(X, 10),
\end{aligned}
$$
## Constants

K which is an array of 64 values $K_{i}$ where each $K_{i}$ is the first 32 first of the fractional parts of the cube roots of the first 64 prime numbers.
K is used during the [hash calculations](#Hash-computation).
A second constant IV is used to [hash initialisation process](#Hash-initialisation).
IV is the fractional part of the square roots of the first 8 prime numbers:

```python
K = [
	0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
	0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
	0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
	0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
	0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
	0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
	0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
	0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
	0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
	0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
	0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
	0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
	0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
	0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
	0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
	0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2,
]

IV = [
	0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
	0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,
]
```
## Padding

Padding ensures that the message has a length that is a multiple of 512 bits.
To calculate the padding, we need the length $l$ in bits of the initial message where $l<2^{64}$
From this we calculate $k$ which is the smallest positive integer such that $l+1+k \equiv 448 \bmod 512$,
The padding is then the following:

- First, a bit 1 is appended,
- Next, $k$ bits 0 are appended where 
- Finally, $l$, represented by exactly 64 bits is added at the end of the message.

>[!important]
The message is always be padded, even if the initial length is already a multiple of 512 .

>[!note]
>We assume that the length of the message can be represented by a 64 -bit integer.
## Block decomposition

For each block $M \in\{0,1\}^{512}, 64$ words of 32 bits each are constructed as follows:

- the first 16 are obtained by splitting $M$ in 32-bit blocks
$$
M=W_{1}\left\|W_{2}\right\| \cdots\left\|W_{15}\right\| W_{16}
$$

- the remaining 48 are obtained with the formula:
$$
W_{i}=\sigma_{1}\left(W_{i-2}\right)+W_{i-7}+\sigma_{0}\left(W_{i-15}\right)+W_{i-16}, \quad 17 \leq i \leq 64 .
$$

>[!important]
>Notice the breakdown here:
>The original message is broken blocks $M_{i}$
>Each block is then broken down into words $W_{i}$

## Hash initialisation

>[!note] note that the indexing is from one here.

1. First, eight variables are set to their initial values, given by the first 32 bits of the fractional part of the square roots of the first 8 prime numbers:

$$
\begin{aligned}
& H_{1}^{(0)}= IV_{1} \quad 
H_{2}^{(0)}= IV_{2}  \quad 
H_{3}^{(0)}= IV_{3}  \quad 
H_{4}^{(0)}= IV_{4}  \\
& H_{5}^{(0)}= IV_{5}  \quad 
H_{6}^{(0)}= IV_{6} \quad 
H_{7}^{(0)}= IV_{7}  \quad 
H_{8}^{(0)}= IV_{8} 
\end{aligned}
$$
## Hash computation

For each 512-bit length block $M^{(1)}, M^{(2)}, \ldots, M^{(N)}$

[Decompose](#Block-decomposition) $M^{(t)}$ into 64 blocks $W_{i}$. 

Set
$$
(a, b, c, d, e, f, g, h)=\left(H_{1}^{(t-1)}, H_{2}^{(t-1)}, H_{3}^{(t-1)}, H_{4}^{(t-1)}, H_{5}^{(t-1)},, H_{6}^{(t-1)}, H_{7}^{(t-1)}, H_{8}^{(t-1)}\right)
$$

Then for each of the 64 words $W_{i}$ 
Calculate these values
$$
\begin{aligned}
T_{1} & =h+\Sigma_{1}(e)+\operatorname{Ch}(e, f, g)+K_{i}+W_{i} \\
T_{2} & =\Sigma_{0}(a)+\operatorname{Ma}(a, b, c) \\
h & =g \\
g & =f \\
f & =e \\
e & =d+T_{1} \\
d & =c \\
c & =b \\
b & =a \\
a & =T_{1}+T_{2}
\end{aligned}
$$

Then compute the new values $H_{j}^{(t)}$ 

$$
\begin{aligned}
H_{1}^{(t)} &= H_{1}^{(t-1)}+a \\
H_{2}^{(t)} &= H_{2}^{(t-1)}+b \\
H_{3}^{(t)} &= H_{3}^{(t-1)}+c \\
H_{4}^{(t)} &= H_{4}^{(t-1)}+d \\
H_{5}^{(t)} &= H_{5}^{(t-1)}+e \\
H_{6}^{(t)} &= H_{6}^{(t-1)}+f \\
H_{7}^{(t)} &= H_{7}^{(t-1)}+g \\
H_{8}^{(t)} &= H_{8}^{(t-1)}+h
\end{aligned}
$$

>[!note]
It is useful to see this middle step graphically so you can see the rotation:
![Hash function](SHA-256.png)
(Image comes from Wikipedia)

## Finalise

- The hash of the message is the concatenation of the variables $H_{i}^{N}$ after the last block has been processed
$$
H=H_{1}^{(N)}\left\|H_{2}^{(N)}\right\| H_{3}^{(N)}\left\|H_{4}^{(N)}\right\| H_{5}^{(N)}\left\|H_{6}^{(N)}\right\| H_{7}^{(N)} \| H_{8}^{(N)} .
$$
## Implementation

### One-Shot

The algorithm above is the **one-shot implementation**, which typically looks like this:

```rust
use hex_literal::hex;
use sha2::{Sha256, Digest};

let result = Sha256::digest(b"hello world");
assert_eq!(result[..], hex!("
    b94d27b9934d3e08a52e52d7da7dabfac484efe37a5380ee9088f7ace2efcde9
")[..]);
```

### Stream

Commonly, this algorithm is implemented using two functions:

1. Update
2. Finalise

which look like this:

```rust
use hex_literal::hex;
use sha2::{Sha256, Sha512, Digest};

// create a Sha256 object
let mut hasher = Sha256::new();

// write input message
hasher.update(b"hello ");
hasher.update(b"world");

// read hash digest and consume hasher
let result = hasher.finalize();

assert_eq!(result[..], hex!("
    b94d27b9934d3e08a52e52d7da7dabfac484efe37a5380ee9088f7ace2efcde9
")[..]);

```

The difference here is that the implementation calls update for each input before finalizing.

This follows the above process with a few changes:

The SHA256 object has 

- A buffer and 
- A counter and 
- An [initialised](#Hash-initialisation) hash $H$.

Note that the counter tracks then number of processed block.

Each update will do the following

- Prepend the message input with whatever is in the buffer.
- [Hash](#Hash-computation) the available 512-bit length blocks. 
- The remainder (that is not long enough to fill a 512-bit block) is stored in the buffer
- Add the number of processed blocks to the counter.

This repeats for each update call.

The finalize then

- Takes whatever is left in the buffer
- Adds the length of the buffer to the counter
- Use the counter to [pad](#Padding) the buffer.
- [Hash](#Hash-computation) the final blocks
- Then [finalise](#Finalise).
### Arithmetic overflows

A key point of the [[#Block decomposition]] and [[#Hash computation]] is that there are a number of addition operations that can result in overflows.
Therefore implemention requires doing arithmetic `modulo 2^32`.
This can be done in a number of ways depending on the language.
This implementation uses [wrapping](https://doc.rust-lang.org/std/num/struct.Wrapping.html) to do this.

